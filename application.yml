# =============================================================================
# Spring Cloud Config - Application Configuration
# =============================================================================
# This file contains APPLICATION-LEVEL configuration shared across all services.
# 
# CONFIGURATION SEPARATION STRATEGY:
# 
# 1. Infrastructure Bootstrap (.env files):
#    - Docker image versions and infrastructure startup
#    - Bootstrap credentials for container startup only
#    - Network and platform configuration
#    - Used by: Docker Compose and Makefile
#
# 2. Application Configuration (this file):
#    - Business logic and application behavior
#    - Service integration patterns (OAuth, service discovery)
#    - Shared application defaults (connection pools, timeouts)
#    - Uses Vault references for runtime secrets
#
# 3. Runtime Secrets (HashiCorp Vault):
#    - Production credentials and sensitive data
#    - Dynamic secret rotation and access control
#    - Integration through Spring Cloud Vault
#
# VAULT SECRET PATHS (configured in Vault):
# - database.username    -> secret/database/username
# - database.password    -> secret/database/password  
# - rabbitmq.username    -> secret/rabbitmq/username
# - rabbitmq.password    -> secret/rabbitmq/password
# - redis.password       -> secret/redis/password
#
# PROFILE USAGE:
# - local,native         -> Filesystem config, no Vault
# - dev,native,vault     -> Filesystem config + Vault secrets
# - dev,vault           -> Git config + Vault secrets
# - prod,vault,performance -> Production Git config + Vault + optimizations
# =============================================================================

spring:
  # Enhanced Security Configuration (shared across all services)
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: ${OAUTH2_ISSUER_URI:http://auth-service:8081/}
          cache-duration: ${JWT_CACHE_DURATION:PT5M}
      client:
        provider:
          custom:
            issuer-uri: ${OAUTH2_ISSUER_URI:http://auth-service:8081/}
            user-name-attribute: preferred_username
  
  # NOTE: Config import is handled per-service to avoid circular dependencies
  # Each service includes this in their bootstrap.yml or application.yml:
  # config:
  #   import: optional:configserver:${SPRING_CLOUD_CONFIG_URI:http://localhost:8888/}
  
  # RabbitMQ Configuration (shared across all services)
  # Uses infrastructure service names and environment variables
  rabbitmq:
    host: rabbitmq  # Infrastructure service name
    port: 5672      # Standard port
    username: ${RABBITMQ_USER}  # From environment
    password: ${RABBITMQ_PASSWORD}  # From environment
    virtual-host: /
    connection-timeout: 10s
    requested-heartbeat: 30s
    publisher-confirm-type: correlated
    publisher-returns: true
    template:
      retry:
        enabled: true
        initial-interval: 1000ms
        max-attempts: 3
        max-interval: 10000ms
        multiplier: 2
  
  # Enhanced Redis Configuration
  # Uses infrastructure service names and environment variables
  data:
    redis:
      host: redis     # Infrastructure service name
      port: 6379      # Standard port
      password: ${REDIS_PASSWORD}  # From environment
      database: 0
      timeout: 2000ms
      ssl:
        enabled: false
      lettuce:
        pool:
          max-active: 8
          max-wait: -1ms
          max-idle: 8
          min-idle: 0
        shutdown-timeout: 100ms
  
  # Database Configuration (for services that use database)
  # Uses infrastructure service names and Vault secrets
  datasource:
    url: jdbc:postgresql://postgres:5432/microservices_db  # Infrastructure service name
    username: ${database.username}  # From Vault
    password: ${database.password}  # From Vault
    driver-class-name: org.postgresql.Driver
    hikari:
      connection-timeout: 20000
      maximum-pool-size: 10
      minimum-idle: 5
      idle-timeout: 300000
      max-lifetime: 1200000
      leak-detection-threshold: 60000
  
  # Enhanced JPA Configuration
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: ${DDL_AUTO:update}
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
    show-sql: ${SHOW_SQL:false}
    properties:
      hibernate:
        format_sql: true
        use_sql_comments: true
        jdbc:
          batch_size: 20
          order_inserts: true
          order_updates: true
        connection:
          provider_disables_autocommit: true
          
eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_DEFAULT_ZONE:http://discovery-service:8761/eureka/}

management:
  endpoint:
    prometheus:
      access: unrestricted  # Updated from deprecated 'enabled: true'
    health:
      probes:
        enabled: true   # Enable liveness/readiness
      show-components: always
      cache:
        time-to-live: 10s
    info:
      cache:
        time-to-live: 10s
    metrics:
      cache:
        time-to-live: 10s
  endpoints:
    web:
      exposure:
        include: health,info,prometheus,metrics,env,configprops
      base-path: /actuator
    jmx:
      exposure:
        include: health,info,metrics
  info:
    git:
      mode: full
    java:
      enabled: true
    os:
      enabled: true
  metrics:
    tags:
      application: ${spring.application.name}
      version: ${BUILD_VERSION:unknown}
      environment: ${SPRING_PROFILES_ACTIVE:default}
    distribution:
      percentiles-histogram:
        http.server.requests: true
      percentiles:
        http.server.requests: 0.5, 0.9, 0.95, 0.99, 0.999
      sla:
        http.server.requests: 50ms, 100ms, 200ms, 500ms
  prometheus:
    metrics:
      export:
        enabled: true
        step: 30s
        descriptions: true
  health:
    redis:
      enabled: true
    rabbit:
      enabled: true
    db:
      enabled: true
    disk-space:
      enabled: true
      threshold: 10MB
  lifecycle:
    timeout-per-shutdown-phase: 30s
  tracing:
    sampling:
      probability: ${TRACING_SAMPLE_RATE:0.1}

springdoc:
  api-docs:
    enabled: true
  swagger-ui:
    enabled: true
    path: /swagger-ui
  # springdoc config above; removed misplaced health.probes (moved under management)

# Standardized logging configuration - applies to all services and profiles
logging:
  file:
    name: ${LOG_PATH:./logs}/${spring.application.name}.log
  pattern:
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    console: "%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n"
  level:
    org.apache.coyote.http11.Http11Processor: INFO  # Suppress DEBUG EOFException logs
    org.apache.tomcat.util.net: INFO
    org.springframework.cloud.config.client.ConfigServicePropertySourceLocator: WARN

---
spring:
  config:
    activate:
      on-profile: prod
management:
  endpoints:
    web:
      exposure:
        include: health,prometheus
springdoc:
  api-docs:
    enabled: false
  swagger-ui:
    enabled: false

# Application level defaults (override per profile as needed)
app:
  cors:
    allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:3000,http://localhost:8080}
    allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS}
    allowed-headers: ${CORS_ALLOWED_HEADERS:*}
    allow-credentials: ${CORS_ALLOW_CREDENTIALS:true}
    max-age: ${CORS_MAX_AGE:3600}
  security:
    jwt:
      expiration: ${JWT_EXPIRATION:3600}
      refresh-expiration: ${JWT_REFRESH_EXPIRATION:86400}
    rate-limit:
      requests-per-second: ${RATE_LIMIT_RPS:100}
      burst-capacity: ${RATE_LIMIT_BURST:200}
  logging:
    queue:
      capacity: 2000
    correlation:
      enabled: true
    request-response:
      enabled: ${ENABLE_REQUEST_LOGGING:false}
  monitoring:
    alerts:
      enabled: ${MONITORING_ALERTS_ENABLED:true}
    health-check:
      interval: ${HEALTH_CHECK_INTERVAL:30s}
  resilience:
    circuit-breaker:
      failure-rate-threshold: ${CB_FAILURE_RATE:50}
      wait-duration-in-open-state: ${CB_WAIT_DURATION:60s}
      permitted-number-of-calls-in-half-open-state: ${CB_HALF_OPEN_CALLS:3}
    retry:
      max-attempts: ${RETRY_MAX_ATTEMPTS:3}
      wait-duration: ${RETRY_WAIT_DURATION:1s}
    timeout:
      default: ${DEFAULT_TIMEOUT:30s}